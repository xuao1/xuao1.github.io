---
title: LeetCode 2023-12
author: xuao
date: 2023-12-02 16:20:00 +800
categories: [LeetCode]
tags: [LeetCode, C++, C, Algorithm]
---

# 解题记录

### 12 月总结

本月有价值的题目：

### 2023-12-01

2661 [找出叠涂元素](https://leetcode.cn/problems/first-completely-painted-row-or-column/description/?envType=daily-question&envId=2023-12-01)

很简单的题目，就是题目描述的不清楚

### 2023-12-02

1094 [拼车 ](https://leetcode.cn/problems/car-pooling/submissions/486262555/?envType=daily-question&envId=2023-12-02)

简单的模拟题

### 2023-12-03

1423 [可获得的最大点数](https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/description/)

比较简单，维护两个前缀和即可

需要注意边界处理

### 2023-12-04

1038 [从二叉搜索树到更大和树](https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/submissions/486758561/)

二叉树后序遍历，没啥难度，不做记录

### 2023-12-05

2477 [到达首都的最少油耗](https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital/submissions/486912826/)

DFS+模拟，不做记录

### 2023-12-06

2646 [最小化旅行的价格总和](https://leetcode.cn/problems/minimize-the-total-price-of-the-trips/submissions/487243223/)

> 一棵树，每个节点有一个价格
>
> 一些旅行路径，路径的价格是路径上所有节点的价格之和
>
> 在执行第一次旅行之前，你可以选择一些 **非相邻节点** 并将价格减半
>
> 返回执行所有旅行的最小价格总和
>
> 节点数 1 <= n <= 50

对于「多条路径」的处理比较简单，记录一个新的 Price，每个节点的 Price = 经过的路径数 * 该节点原本的价格

关键问题是如何选择价格减半的节点，以下简称为「染色」，被染色的节点价格减半

最开始的想法是暴搜，但是枚举每种可能的染色方式比较困难。

考虑**动态规划**

维护两个数组：

+ `subtrees0[i]`：以 i 为根节点的子树，的最小价格，i 不染色
+ `subtrees0[i]`：以 i 为根节点的子树，的最小价格，i 染色

那么状态转移方程为：

![LeetCode-image1]({{ site.url }}/my_img/LeetCode-image1.png)

核心动态规划代码：

```c++
void DP(int pre, int node){
    for(auto& next: MatrixEdges[node]){
        if(next == pre) continue;
        DP(node, next);
        subtrees0[node] += min(subtrees0[next], subtrees1[next]);
        subtrees1[node] += subtrees0[next];
    }
    subtrees0[node] += NewPrice[node];
    subtrees1[node] += NewPrice[node] / 2;
}
```

### 2023-12-07

1466 [重新规划路线](https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/submissions/487440534/)

DFS，不做记录

### 2023-12-08

> 一条单向直路线，一共 n 个地点，编号 1~n
>
> 驾驶出租车，乘客信息用一个下标从 **0** 开始的二维数组 `rides` 表示，其中 `rides[i] = [starti, endi, tipi]` 表示第 `i` 位乘客需要从地点 `starti` 前往 `endi` ，愿意支付 `tipi` 元的小费
>
> **每一位** 你选择接单的乘客 `i` ，你可以 **盈利** `endi - starti + tipi` 元。你同时 **最多** 只能接一个订单
>
> 求最大盈利

动态规划，`DP[i]` 表示到达 i，最大盈利是多少

状态转移方程为：

`DP[i] = max(DP[i-1], DP[start_k] + end_k - start_k + tip_k), for all k that end_k == i`

这里的 `DP[i-1]` 是一处细节 

核心代码：

```c++
vector<long long> dp(n + 1, 0);
vector<vector<pair<int, int>>> v(n + 1);
for(auto& ride : rides){
    v[ride[1]].push_back({ride[0], ride[1] - ride[0] + ride[2]});
}
for(int i = 1; i <= n; i++){
    dp[i] = dp[i - 1];
    for(auto& p : v[i]){
        dp[i] = max(dp[i], dp[p.first] + p.second);
    }
}
```

另外一开始想着按照 rides 递归，对其从小到大排序，后来发现行不通，但是排序的代码值得记录一下：

```c++
sort(rides.begin(), rides.end(), [](const vector<int>& a, const vector<int>& b){
    return a[1] < b[1];
});
```

### 2023-12-09

2048 [下一个更大的数值平衡数](https://leetcode.cn/problems/next-greater-numerically-balanced-number/submissions/487821861/)

比较简单，不做记录
