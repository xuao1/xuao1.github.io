---
title: LeetCode 2023-12
author: xuao
date: 2023-12-02 16:20:00 +800
categories: [LeetCode]
tags: [LeetCode, C++, C, Algorithm]
---

# 解题记录

### 12 月总结

本月有价值的题目：

### 2023-12-1

2661 [找出叠涂元素](https://leetcode.cn/problems/first-completely-painted-row-or-column/description/?envType=daily-question&envId=2023-12-01)

很简单的题目，就是题目描述的不清楚

### 2023-12-2

1094 [拼车 ](https://leetcode.cn/problems/car-pooling/submissions/486262555/?envType=daily-question&envId=2023-12-02)

简单的模拟题

### 2023-12-3

1423 [可获得的最大点数](https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/description/)

比较简单，维护两个前缀和即可

需要注意边界处理

### 2023-12-4

1038 [从二叉搜索树到更大和树](https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/submissions/486758561/)

二叉树后序遍历，没啥难度，不做记录

### 2023-12-5

2477 [到达首都的最少油耗](https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital/submissions/486912826/)

DFS+模拟，不做记录

### 2023-12-6

2646 [最小化旅行的价格总和](https://leetcode.cn/problems/minimize-the-total-price-of-the-trips/submissions/487243223/)

> 一棵树，每个节点有一个价格
>
> 一些旅行路径，路径的价格是路径上所有节点的价格之和
>
> 在执行第一次旅行之前，你可以选择一些 **非相邻节点** 并将价格减半
>
> 返回执行所有旅行的最小价格总和
>
> 节点数 1 <= n <= 50

对于「多条路径」的处理比较简单，记录一个新的 Price，每个节点的 Price = 经过的路径数 * 该节点原本的价格

关键问题是如何选择价格减半的节点，以下简称为「染色」，被染色的节点价格减半

最开始的想法是暴搜，但是枚举每种可能的染色方式比较困难。

考虑**动态规划**

维护两个数组：

+ `subtrees0[i]`：以 i 为根节点的子树，的最小价格，i 不染色
+ `subtrees0[i]`：以 i 为根节点的子树，的最小价格，i 染色

那么状态转移方程为：
$$
subtrees0[i] = \sum min(subtrees0[next], subtrees1[next]) 
\\
subtrees0[i] = \sum subtrees0[next] 
$$
核心动态规划代码：

```c++
void DP(int pre, int node, int n){
    for(auto& next: MatrixEdges[node]){
        if(next == pre) continue;
        DP(node, next, n);
        subtrees0[node] += min(subtrees0[next], subtrees1[next]);
        subtrees1[node] += subtrees0[next];
    }
    subtrees0[node] += NewPrice[node];
    subtrees1[node] += NewPrice[node] / 2;
}
```

